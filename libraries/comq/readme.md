# ComQ

Distributed system communications over [AMQP](https://github.com/amqp-node/amqplib) for
Node.js.

## Features

1. Dynamic topology
2. [Request](#request)-[reply](#reply) (RPC)
3. Events ([pub](#emission)/[sub](#consumption))
4. [Content encoding](#encoding)
5. [Consumer acknowledgements](#acknowledgements) and [publisher confirms](#io-segregation)
6. [Connection tolerance](#connection-tolerance)
7. Broker restart [resilience](#persistence)
8. [Flow control](#io-segregation) with back pressure handling
9. [Graceful shutdown](#graceful-shutdown)

## TL;DR

[Code examples](examples)

## Installation

`npm i comq`

## Connect

`async connect(url: string): IO`

Returns an instance of [`IO`](types/io.d.ts) once a successful connection to the broker is
established.

`url` is passed
to [`amqplib.connect`](https://amqp-node.github.io/amqplib/channel_api.html#connect).

### Example

```javascript
const { connect } = require('comq')

const url = 'amqp://developer:secret@localhost'
const io = await connect(url)

// ...

await io.close()
```

## Definitions

The following documentation refers to a few terms:

**Request** is an AMQP message that has the `replyTo` and `correlationId` properties set.

**Reply** is an AMQP message sent in response to a Request and sent to the queue specified in
the `replyTo` property of the Request. The `correlationId` property of the Reply is set to the same
value as in the Request.

**Event** is an AMQP message that is published to an exchange.

**Producer** is an application role that receives Requests and produces Replies and Events.

**Consumer** is an application role that sends Requests and consumes Replies and Events.

## Reply

`async IO.reply(queue: string, producer)`

`producer` function's signature is `async? (message: any): any`

Assert a `queue` and start consuming Requests. Received messages are decoded and the resulting
content is passed to the `producer`. The result generated by the `producer` is then encoded and sent
back to the queue specified in the `replyTo` property of the Request, along with a `correlationId`
that has the same value as in the Request.

Reply message is encoded using the same encoding format as the Request message has, if it is
specified and supported, unless `producer` returned `Buffer`, in which case encoding format will be
set to `application/octet-stream`. If encoding format of the Request message isn't specified or
supported and `producer` has returned value that isn't a `Buffer`, then exception is thrown.

> If incoming message doesn't have a `replyTo` property, an exception is thrown without
> calling `producer`.

> `replyTo` queue is not asserted, therefore a Request message with `replyTo` referring to a
> non-existent queue will cause an exception.

### Example

```javascript
await io.reply('add_numbers', ({ a, b }) => (a + b))
```

## Request

`async IO.request(queue: string, payload: any, [encoding: string])`

Send encoded Request message with `replyTo` and `correlationId` properties set and
return decoded Reply content.

On the initial call, a queue for Requests and a [temporary](#persistence) queue for Replies are
asserted.

### Example

```javascript
const sum = await io.request('add_numbers', { a: 1, b: 2 })

console.log(sum) // 3
```

## Consumption

`async IO.consume(exchange: string, group: string, consumer)`

`consumer` function's signature is `async? (payload: any): void`

Start consuming decoded Events.

On the initial call (once per unique `exchange` value), asserts fanout `exchange` and queue for the
Consumer `group`, and then binds the queue to the exchange. That is, one Event message is delivered
to a single Consumer within *each group*.

> Typically, the value of `group` refers to the name of a microservice running in multiple
> instances.

### Example

```javascript
await io.consume('numbers_added', 'logger', ({ a, b }) => {
  console.log(`${a} was added to ${b}`)
})
```

## Emission

`async IO.emit(exchange: string, payload: any, [encoding: string])`

Publish encoded Events to the `exchange`.

On the initial call,
a [fanout exchange](https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchanges) is
asserted.

### Example

```javascript
await io.emit('numbers_added', { a: 1, b: 2 })
```

## Encoding

By default, outgoing message contents are encoded with [msgpack](https://msgpack.org) and
the `contentType` property is set to `application/msgpack`. If encoding format is
specified ([request](#request), [emit](#emission)) and supported, contents are encoded accordingly.

Exceptions are Buffers, which are sent without encoding and the `contentType` property set
to specified encoding format or `application/octet-stream` if it's not specified.

Incoming messages are decoded based on the presence and value of the `contentType` property. If the
header is present and its value is supported, the message is decoded. If the header is missing or
its value is `application/octet-stream` or is not supported, the message is passed as a raw Buffer
object.

The following content types are supported:

- `application/msgpack`
- `application/json`

## Connection Tolerance

On the initial connection or if the established connection is temporarily lost, ComQ will keep
attempting to connect to the broker indefinitely with increasing intervals (up to 30 seconds). If
the broker rejects the connection (e.g. due to access being denied), an exception will be thrown.

## Persistence

- Queues and exchanges
  are [durable](https://amqp-node.github.io/amqplib/channel_api.html#channel_assertQueue)
- [Temporary](#request) queues have 1 hour [TTL](https://www.rabbitmq.com/ttl.html#queue-ttl)
  (currently non-configurable)
- Outgoing messages
  are [persistent](https://amqp-node.github.io/amqplib/channel_api.html#channel_publish)

## Acknowledgements

Incoming messages are "positive
acknowledged" ([ack](https://amqp-node.github.io/amqplib/channel_api.html#channel_ack)), unless
message handler function throws an exception. Messages are **not** "negative
acknowledged" ([nack](https://amqp-node.github.io/amqplib/channel_api.html#channel_nack)) as it's
assumed, that the handler's exception will cause
the [process to crash](#it-will-crash). In this scenario,
RabbitMQ [will requeue](https://www.rabbitmq.com/confirms.html#automatic-requeueing) the message due
to a connection loss.

Outgoing messages are considered as *sent*
when a [confirmation](https://www.rabbitmq.com/confirms.html#publisher-confirms) is received.

See [Consumer Acknowledgements and Publisher Confirms](https://www.rabbitmq.com/confirms.html).

## I/O Segregation

`IO` creates two channels: input and output.

Input channel is used to consume Requests and Events. It
has [prefetch count](https://www.rabbitmq.com/confirms.html#channel-qos-prefetch) set to `300`
(currently non-configurable).

Output channel is
a [ConfirmChannel](https://amqp-node.github.io/amqplib/channel_api.html#confirmchannel) used to send
Requests, emit Events, send *and consume* Replies. The channel's prefetch count is infinite, and it
handles the [back pressure mechanism](https://www.rabbitmq.com/flow-control.html).

I/O segregation addresses the potential issue of a *prefetch deadlock*. If you use the same channel
or channel pool for both inputs and outputs, you may consume the maximum number of messages allowed
by the prefetch setting, but then processing functions that send outgoing requests will not be able
to receive replies since the prefetch limit has already been reached.

## Graceful Shutdown

### Sealing

`async IO.seal()`

[Stop receiving](https://amqp-node.github.io/amqplib/channel_api.html#channel_cancel) new Events and
Requests.

### Disconnection

`async IO.close()`

1. Call `IO.seal()`.
2. Wait for any outstanding messages to be processed and acknowledged. Sending Requests, receiving
   Replies, and emitting Events will still be available.
3. Close the connection.

### Advanced Scenarios

`IO.close()` tracks the completion of [`producer`](#reply) and [`consumer`](#consumption) function
calls, by waiting for their returned promises to be settled. However, it is possible for an attempt
to be made to send an outgoing message after the connection has been closed, resulting in the
`Channel ended, no reply will be forthcoming` exception. This may occur *at least* in the following
scenarios:

1. The `producer` or `consumer` function spawns a new asynchronous context that attempts to send an
   outgoing message after the returned promise has been settled.
2. Your application has other incoming communication channels, such as an HTTP API, that may lead to
   an attempt to send an outgoing message after `IO.close()` has closed the connection.

In these or other similar scenarios, it is recommended to call `IO.seal()` to stop receiving new
messages, ensure that any code execution that may send outgoing messages is completed before
calling `IO.close()`.

## Diagnostics

`IO` emits events for testing, diagnostics, or logging purposes.

`IO.diagnose(event: string, listener: Function): void`

Subscribe to one of the diagnostic events:

- `open`: connection is restored[^1]
- `close`: connection is [closed](https://amqp-node.github.io/amqplib/channel_api.html#model_events)
- `flow`: back pressure is applied to an output channel
- `drain`: back pressure is removed from an output channel

[^1]: As [`connect`](#connect) function returns an instance of `IO` *after* the connection has been
established, there is no way to capture the initial `open` event.

### Example

```javascript
io.diagnose('flow', () => console.log('Back pressure was applied'))
```

## It Will Crash

Neither connection nor channel errors are handled, thus, the
process [will crash](https://www.reactivedesignpatterns.com/patterns/let-it-crash.html) in case any
of them.
