# ComQ

Distributed system communications over [AMQP](https://github.com/amqp-node/amqplib) for
Node.js.

## Features

1. Zero configuration
2. [Request](#request)-[reply](#reply) (RPC)
3. Events ([pub](#emission)/[sub](#consumption))
4. [Message acknowledgement](#acknowledgement)
5. [Flow control](#io-channels)
6. [Content encoding](#encoding)
7. [Graceful shutdown](#graceful-shutdown)
8. Broker restart or connection loss [resilience](#persistence)

> Features are described in the [`features`](features) directory. To run them you should start
> RabbitMQ server with `docker compose up -d`, then execute `npm run test:features`

## Installation

`npm i comq`

## Connect

`async connect(url: string): IO`

`url` is passed
to [`amqplib.connect`](https://amqp-node.github.io/amqplib/channel_api.html#connect).

### Example

```javascript
const { connect } = require('comq')

const url = 'amqp://developer:secret@localhost'
const io = await connect(url)

// ...

await io.close()
```

## Reply

`async IO.reply(queue: string, producer)`

`producer` function's signature is `async? (message: any): any`

Assert a `queue` and start consuming messages (requests). Received messages are decoded and
the resulting content is passed to the specified `producer`. The result generated by the `producer`
is then encoded and sent back to the queue specified in the `replyTo` property, along with
a `correlationId` that has the same value as in the original request.

Reply message is encoded using the same encoding format as the request message, if it is specified
and supported, unless `producer` returned `Buffer`, in which case encoding format will be set
to `application/octet-stream`. If encoding format of the request message isn't specified or
supported and `producer` has returned value that isn't a `Buffer`, then exception is thrown.

> If incoming message doesn't have a `replyTo` property, an exception is thrown without
> calling `producer`.

> `replyTo` queue is not asserted, therefore a request message with `replyTo` referring to a
> non-existent queue will cause an AMQP channel error.

### Example

```javascript
await io.reply('add_numbers', ({ a, b }) => (a + b))
```

## Request

`async IO.request(queue: string, payload: any, [encoding: string])`

Send encoded request message with `replyTo` and `correlationId` properties set and
return decoded reply.

On the initial call, a queue for requests and a [transient](#persistence) queue for replies are
asserted.

### Example

```javascript
const sum = await io.request('add_numbers', { a: 1, b: 2 })

console.log(sum) // 3
```

## Emission

`async IO.emit(exchange: string, payload: any, [encoding: string])`

Publish encoded event message to the `exchange`.

On the initial call,
a [fanout exchange](https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchanges) is
asserted.

### Example

```javascript
await io.emit('numbers_added', { a: 1, b: 2 })
```

## Consumption

`async IO.consume(exchange: string, group: string, consumer)`

`consumer` function's signature is `async? (message: any): void`

Assert durable fanout `exchange` and durable queue for the consumer `group`, and then bind the queue
to the exchange. Essentially, one event message is delivered to a single consumer within *each
group*.

> Typically, the value of `group` refers to the name of a microservice running in multiple
> instances.

### Example

```javascript
await io.consume('numbers_added', 'logger', (payload) => {
  console.log(`${payload.a} was added to ${payload.b}`)
})
```

## Encoding

By default, outgoing message contents are encoded with [msgpack](https://msgpack.org) and
the `contentType` property is set to `application/msgpack`. If encoding format is
specified ([request](#request), [emit](#emission)) and supported, contents are encoded accordingly.

Exceptions are Buffers, which are sent without encoding and the `contentType` property set
to specified encoding format or `application/octet-stream` if it's not specified.

Incoming messages are decoded based on the presence and value of the `contentType` property. If the
header is present and its value is supported, the message is decoded. If the header is missing or
its value is `application/octet-stream` or is not supported, the message is passed as a raw Buffer
object.

The following content types are supported:

- `application/msgpack`
- `application/json`

## IO Channels

`IO` lazy creates two channels: input and output.

Input channel is used to consume requests and events. It
has [prefetch count](https://www.rabbitmq.com/confirms.html#channel-qos-prefetch) set to `300`
(currently, non-configurable).

Output channel is
a [ConfirmChannel](https://amqp-node.github.io/amqplib/channel_api.html#confirmchannel) used to send
requests, emit events, send *and consume* replies.

## Graceful shutdown

`async IO.seal()` closes input channel, that is, guarantees no more requests or events will be
consumed. Output channel remains available.

`async IO.close()` closes both input (if it hasn't been closed before) and output channels.

It is recommended to call `.seal()`, finish processing current requests and events, and then
call `.close()`.

## Persistence

Queues and exchanges are `durable`. Transient queues have 1
hour [TTL](https://www.rabbitmq.com/ttl.html#queue-ttl) (non-configurable currently). Messages are
sent with [`delivery mode` 2](https://www.rabbitmq.com/publishers.html#message-properties).

## Acknowledgement

Incoming messages are "positive
acknowledged" ([ack](https://amqp-node.github.io/amqplib/channel_api.html#channel_ack)), unless
message handler function throws an exception. Messages are **not** "negative
acknowledged" ([nack](https://amqp-node.github.io/amqplib/channel_api.html#channel_nack)) as it's
assumed, that the handler's exception will cause
the [process to crash](https://www.reactivedesignpatterns.com/patterns/let-it-crash.html). In this
scenario, RabbitMQ [will requeue](https://www.rabbitmq.com/confirms.html#automatic-requeueing) the
message due to a connection loss.
