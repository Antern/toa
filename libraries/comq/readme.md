# ComQ

Distributed system communications over [AMQP](https://github.com/amqp-node/amqplib) for
Node.js.

## Features

1. Dynamic topology
2. [Request](#request)-[reply](#reply) (RPC)
3. Events ([pub](#emission)/[sub](#consumption))
4. [Consumer acknowledgements](#acknowledgements)
5. [Publisher confirms](#io-channels)
6. [Flow control](#io-channels)
7. [Back pressure](https://amqp-node.github.io/amqplib/channel_api.html#flowcontrol) handling
8. [Content encoding](#encoding)
9. [Graceful shutdown](#graceful-shutdown)
10. Broker restart and connection loss [resilience](#persistence)

## TL;DR

[Code examples](examples)

## Installation

`npm i comq`

## Connect

`async connect(url: string): IO`

Returns an instance of [`IO`](types/io.d.ts) once a successful connection to the broker is
established.

`url` is passed
to [`amqplib.connect`](https://amqp-node.github.io/amqplib/channel_api.html#connect).

### Example

```javascript
const { connect } = require('comq')

const url = 'amqp://developer:secret@localhost'
const io = await connect(url)

// ...

await io.close()
```

## Definitions

The following documentation refers to a few terms:

**Request** is an AMQP message that has the `replyTo` and `correlationId` properties set.

**Reply** is an AMQP message sent in response to a Request and sent to the queue specified in
the `replyTo` property of the Request. The `correlationId` property of the Reply is set to the same
value as in the Request.

**Event** is an AMQP message that is published to an exchange.

**Producer** is an application role that receives Requests and produces Replies and Events.

**Consumer** is an application role that sends Requests and receives Replies and Events.

## Reply

`async IO.reply(queue: string, producer)`

`producer` function's signature is `async? (message: any): any`

Assert a `queue` and start consuming messages (Requests). Received messages are decoded and
the resulting content is passed to the specified `producer`. The result generated by the `producer`
is then encoded and sent back to the queue specified in the `replyTo` property, along with
a `correlationId` that has the same value as in the original Request.

Reply message is encoded using the same encoding format as the Request message, if it is specified
and supported, unless `producer` returned `Buffer`, in which case encoding format will be set
to `application/octet-stream`. If encoding format of the Request message isn't specified or
supported and `producer` has returned value that isn't a `Buffer`, then exception is thrown.

> If incoming message doesn't have a `replyTo` property, an exception is thrown without
> calling `producer`.

> `replyTo` queue is not asserted, therefore a Request message with `replyTo` referring to a
> non-existent queue will cause an AMQP channel error.

### Example

```javascript
await io.reply('add_numbers', ({ a, b }) => (a + b))
```

## Request

`async IO.request(queue: string, payload: any, [encoding: string])`

Send encoded Request message with `replyTo` and `correlationId` properties set and
return decoded Reply content.

On the initial call, a queue for Requests and a [temporary](#persistence) queue for Replies are
asserted.

### Example

```javascript
const sum = await io.request('add_numbers', { a: 1, b: 2 })

console.log(sum) // 3
```

## Consumption

`async IO.consume(exchange: string, group: string, consumer)`

`consumer` function's signature is `async? (message: any): void`

Assert fanout `exchange` and queue for the Consumer `group`, and then bind the queue to the
exchange. Essentially, one Event message is delivered to a single Consumer within *each group*.
Received Events are decoded and passed to the `consumer`.

> Typically, the value of `group` refers to the name of a microservice running in multiple
> instances.

### Example

```javascript
await io.consume('numbers_added', 'logger', (payload) => {
  console.log(`${payload.a} was added to ${payload.b}`)
})
```

## Emission

`async IO.emit(exchange: string, payload: any, [encoding: string])`

Publish encoded Event message to the `exchange`.

On the initial call,
a [fanout exchange](https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchanges) is
asserted.

### Example

```javascript
await io.emit('numbers_added', { a: 1, b: 2 })
```

## Encoding

By default, outgoing message contents are encoded with [msgpack](https://msgpack.org) and
the `contentType` property is set to `application/msgpack`. If encoding format is
specified ([request](#request), [emit](#emission)) and supported, contents are encoded accordingly.

Exceptions are Buffers, which are sent without encoding and the `contentType` property set
to specified encoding format or `application/octet-stream` if it's not specified.

Incoming messages are decoded based on the presence and value of the `contentType` property. If the
header is present and its value is supported, the message is decoded. If the header is missing or
its value is `application/octet-stream` or is not supported, the message is passed as a raw Buffer
object.

The following content types are supported:

- `application/msgpack`
- `application/json`

## IO Channels

`IO` lazy creates two channels: input and output.

Input channel is used to consume Requests and Events. It
has [prefetch count](https://www.rabbitmq.com/confirms.html#channel-qos-prefetch) [initially](#cause-effect-confirmation-lag)
set to `300` (currently, non-configurable).

Output channel is
a [ConfirmChannel](https://amqp-node.github.io/amqplib/channel_api.html#confirmchannel) used to send
Requests, emit Events, send *and consume* Replies.

## Graceful Shutdown

`async IO.seal()` closes input channel, that is, guarantees no more Requests or Events will be
consumed. Output channel remains available.

`async IO.close()` closes both input (if it hasn't been closed before) and output channels.

It is recommended to call `.seal()`, finish processing current Requests and Events, and then
call `.close()`.

## Persistence

Queues and exchanges
are [durable](https://amqp-node.github.io/amqplib/channel_api.html#channel_assertQueue). [Temporary](#request)
queues have 1 hour [TTL](https://www.rabbitmq.com/ttl.html#queue-ttl) (non-configurable currently).
Outgoing messages
are [`persistent`](https://amqp-node.github.io/amqplib/channel_api.html#channel_publish).

## Acknowledgements

Incoming messages are "positive
acknowledged" ([ack](https://amqp-node.github.io/amqplib/channel_api.html#channel_ack)), unless
message handler function throws an exception. Messages are **not** "negative
acknowledged" ([nack](https://amqp-node.github.io/amqplib/channel_api.html#channel_nack)) as it's
assumed, that the handler's exception will cause
the [process to crash](https://www.reactivedesignpatterns.com/patterns/let-it-crash.html). In this
scenario, RabbitMQ [will requeue](https://www.rabbitmq.com/confirms.html#automatic-requeueing) the
message due to a connection loss.

See [Consumer Acknowledgements and Publisher Confirms](https://www.rabbitmq.com/confirms.html).

## Diagnostics

`IO` emits events for testing, diagnostics, or logging purposes.

`IO.diagnose(event: string, listener: Function): void`

Subscribe to one of the diagnostic events:

- `flow`: back pressure has been applied by an output channel
- `drain`: back pressure has been removed from an output channel

### Example

```javascript
io.diagnose('flow', () => console.log('Back pressure has been applied'))
```
