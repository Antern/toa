# ComQ

Microservice communications over [AMQP](https://github.com/amqp-node/amqplib) for
Node.js.

## Features

1. No static configuration
2. [Request](#request)-[reply](#reply) (RPC)
3. Events (pub/sub)
4. Reconnection handling
5. Flow control
6. Content encoding/decoding
7. Graceful shutdown

> Features are described in the [`features`](features) directory. To run them you should start
> RabbitMQ server with `docker compose up -d`, then execute `npm run test:features`

## Installation

`npm i comq`

## Connect

`async connect(url: string): IO`

`url` is passed
to [`amqplib.connect`](https://amqp-node.github.io/amqplib/channel_api.html#connect).

### Example

```javascript
const { connect } = require('comq')

const url = 'amqp://developer:secret@localhost'
const io = await connect(url)

// ...

await io.close()
```

## Reply

`async IO.reply(queue: string, producer)`

`producer`'s signature is `async (message: any): any`

Assert a durable `queue` and start consuming messages (requests). Received messages are decoded and
the resulting content is passed to the specified `producer`. The result generated by the `producer`
is then encoded and sent back to the queue specified in the `replyTo` property, along with
a `correlationId` that has the same value as in the original request.

Reply message is encoded using the same encoding format as the request message, if it is specified
and supported, unless `producer` returned `Buffer`, in which case encoding format will be set
to `application/octet-stream`. If encoding format of the request message isn't specified or
supported and `producer` has returned value isn't `Buffer`, then exception is thrown.

> If incoming message doesn't have a `replyTo` property, an exception is thrown without
> calling `producer`.
>
> `replyTo` queue is not asserted, therefore a request message with `replyTo` referring to a
> non-existent queue will cause an AMQP channel error.

### Example

```javascript
await io.reply('add_numbers', (payload) => (payload.a + payload.b))
```

## Request

`async IO.request(queue: string, payload: any, [encoding: string])`

Send encoded request message with `replyTo`, `contentType` and `correlationId` properties set and
return decoded reply.

By default, request message contents are encoded using [msgpack](https://msgpack.org) with
a `contentType` property set to `application/msgpack`. If encoding format is specified and
supported, contents are encoded accordingly.

Exceptions to this are Buffers, which are sent without encoding and a `contentType` property set
to specified encoding format or `application/octet-stream` if it's not specified.

On the initial call, a [durable](https://www.rabbitmq.com/queues.html#properties) queue for
requests and an [exclusive](https://www.rabbitmq.com/queues.html#properties) queue for replies are
asserted.

[^1]: [Queue properties](https://www.rabbitmq.com/queues.html#properties)

### Example

```javascript
const sum = await io.request('add_numbers', { a: 1, b: 2 })

console.log(sum) // 3
```

## Decoding

Incoming messages are decoded based on the presence and value of the `contentType` property. If the
header is present and its value is supported, the message is decoded accordingly. If the header is
missing or its value is `application/octet-stream` or not supported, the message is passed as a raw
Buffer object.

The following `contentType` values are supported:

- `application/msgpack`
- `application/json`

## IO Channels

`IO` lazy creates two channels: input and output.

Input channel is used for consuming requests and events. It has prefetch count set to `300`
(currently, not configurable).

Output channel is
a [ConfirmChannel](https://amqp-node.github.io/amqplib/channel_api.html#confirmchannel) used to send
requests, emit events, send and *receive* replies (see [below](#graceful-shutdown)).

## Graceful shutdown

`IO.seal()` closes input channel, that is, guarantees no more requests or events will be consumed.
Output channel remains available.

`IO.close()` closes both input (if it hasn't been closed before) and output channels.

If an application acts both as a producer and as a consumer, to shut it down it is recommended to
call `.seal()`, finish processing current requests and events, and then call `.close()`.
