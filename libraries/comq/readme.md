# ComQ

Distributed system communications over [AMQP](https://github.com/amqp-node/amqplib) for
Node.js.

## Features

1. Dynamic topology
2. Request-reply (RPC)
3. Events (pub/sub)
4. Content encoding
5. Flow control with back pressure handling
6. Consumer acknowledgements and publisher confirms
7. Connection tolerance
8. Broker restart resilience
9. Graceful shutdown

## TL;DR

[Code examples](examples)

## Installation

`npm i comq`

## Connect

`async connect(url: string): IO`

Returns an instance of [`IO`](types/io.d.ts) once a successful connection to the broker is
established.

`url` is passed
to [`amqplib.connect`](https://amqp-node.github.io/amqplib/channel_api.html#connect).

### Example

```javascript
const { connect } = require('comq')

const url = 'amqp://developer:secret@localhost'
const io = await connect(url)

// ...

await io.close()
```

## Definitions

The following documentation refers to a few terms:

**Request** is an AMQP message that has the `replyTo` and `correlationId` properties set.

**Reply** is an AMQP message sent in response to a Request and sent to the queue specified in
the `replyTo` property of the Request. The `correlationId` property of the Reply is set to the same
value as in the Request.

**Event** is an AMQP message that is published to an exchange.

**Producer** is an application role that receives Requests and produces Replies and Events.

**Consumer** is an application role that sends Requests and consumes Replies and Events.

## Reply

`async IO.reply(queue: string, producer)`

`producer` function's signature is `async? (message: any): any`

Assert a `queue` and start consuming Requests. Received messages are decoded and the resulting
content is passed to the `producer`. The result generated by the `producer` is then encoded and sent
back to the queue specified in the `replyTo` property of the Request, along with a `correlationId`
that has the same value as in the Request.

Reply message is encoded using the same encoding format as the Request message has, if it is
specified and supported, unless `producer` returned `Buffer`, in which case encoding format will be
set to `application/octet-stream`. If encoding format of the Request message isn't specified or
supported and `producer` has returned value that isn't a `Buffer`, then exception is thrown.

> If incoming message doesn't have a `replyTo` property, an exception is thrown without
> calling `producer`.

### Example

```javascript
await io.reply('add_numbers', ({ a, b }) => (a + b))
```

## Request

`async IO.request(queue: string, payload: any, [encoding: string])`

Send encoded Request message with `replyTo` and `correlationId` properties set and
return decoded Reply content.

On the initial call, a queue for Requests and a [temporary](#persistence) queue for Replies are
asserted.

### Example

```javascript
const sum = await io.request('add_numbers', { a: 1, b: 2 })
```

## Consumption

`async IO.consume(exchange: string, group: string, consumer)`

`consumer` function's signature is `async? (payload: any): void`

Start consuming decoded Events.

On the initial call (once per unique `exchange` value), asserts fanout `exchange` and queue for the
Consumer `group`, and then binds the queue to the exchange. That is, one Event message is delivered
to a single Consumer within *each group*.

> Typically, the value of `group` refers to the name of a microservice running in multiple
> instances.

### Example

```javascript
await io.consume('numbers_added', 'logger', ({ a, b }) => {
  console.log(`${a} was added to ${b}`)
})
```

## Emission

`async IO.emit(exchange: string, payload: any, [encoding: string])`

Publish encoded Events to the `exchange`.

On the initial call,
a [fanout exchange](https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchanges) is
asserted.

### Example

```javascript
await io.emit('numbers_added', { a: 1, b: 2 })
```

## Encoding

By default, outgoing message contents are encoded with [msgpack](https://msgpack.org) and
the `contentType` property is set to `application/msgpack`. If encoding format is
specified ([request](#request), [emit](#emission)) and supported, contents are encoded accordingly.

Exceptions are Buffers, which are sent without encoding and the `contentType` property set
to specified encoding format or `application/octet-stream` if it's not specified.

Incoming messages are decoded based on the presence and value of the `contentType` property. If the
header is present and its value is supported, the message is decoded. If the header is missing or
its value is `application/octet-stream` or is not supported, the message is passed as a raw Buffer
object.

The following content types are supported:

- `application/msgpack`
- `application/json`
- `text/plain`

## Connection Tolerance

When initially connecting to the broker or if the established connection is lost, connection
attempts will be repeated indefinitely with intervals increasing up to 30 seconds. Once reconnected,
the topology will be recovered, and unanswered Requests and unconfirmed Events will be resent.

If the broker rejects the connection (for example, due to access being denied), an exception will be
thrown.

## Topology

Topology is designed to deliver maximum performance while ensuring that the **at least once**
guarantee provided by RabbitMQ is maintained.

> Topology design assumes that unanswered Requests and unconfirmed Events will be resent upon
> reconnection.

### Channels

`IO` lazy creates individual channels for Requests, Replies, and Events.

- [Prefetch count](https://www.rabbitmq.com/confirms.html#channel-qos-prefetch) for incoming
  Requests and Events are separated. Each is set to `300` (currently non-configurable).
- Incoming Replies have no prefetch limit.
- Outgoing Events are transmitted
  using [confirmation mechanism](https://www.rabbitmq.com/confirms.html#publisher-confirms).

Channel segregation addresses the potential issue of a prefetch deadlock[^1], which may take place
when using a single channel or channel pool.

[^1]: maximum amount of messages is consumed, while handlers of those messages are expecting
replies.

### Exchanges and Queues

- Exchanges and queues for Events, and queues for Requests
  are [durable](https://amqp-node.github.io/amqplib/channel_api.html#channel_assertQueue).
- Queues for Replies are *exclusive*.

### Messages

- Events are
  *persistent* ([delivery mode 2](https://www.rabbitmq.com/publishers.html#message-properties)),
  while Requests and Replies are not (mode 1).
- Events and Requests are consumed using
  manual [acknowledgment mode](https://www.rabbitmq.com/confirms.html#acknowledgement-modes),
  and Replies are consumed using automatic mode.

> Messages are **not** "negative
> acknowledged" in case of an exception in the handler function, as it is expected to cause
> the [process to crash](https://www.reactivedesignpatterns.com/patterns/let-it-crash.html). In this
> scenario, RabbitMQ [will requeue](https://www.rabbitmq.com/confirms.html#automatic-requeueing) the
> message due to a connection loss.

See [Consumer Acknowledgements and Publisher Confirms](https://www.rabbitmq.com/confirms.html).

### Cheatsheet

| Message | Prefetch  | Confirms | Queue     | Acknowledgement | Persistent |
|---------|-----------|----------|-----------|-----------------|------------|
| Request | limited   | no       | durable   | manual          | no         |
| Reply   | unlimited | no       | exclusive | automatic       | no         |
| Event   | limited   | yes      | durable   | manual          | yes        |

## Graceful Shutdown

### Sealing

`async IO.seal()`

[Stop receiving](https://amqp-node.github.io/amqplib/channel_api.html#channel_cancel) new Events and
Requests.

### Disconnection

`async IO.close()`

1. Call `IO.seal()`.
2. Wait for any outstanding messages to be processed and acknowledged. Sending Requests, receiving
   Replies, and emitting Events will still be available.
3. Close the connection.

### Advanced Scenarios

`IO.close()` tracks the completion of [`producer`](#reply) and [`consumer`](#consumption) function
calls, by waiting for their returned promises to be settled. However, it is possible for an attempt
to be made to send an outgoing message after the connection has been closed, resulting in the
`Channel ended, no reply will be forthcoming` exception. This may occur *at least* in the following
scenarios:

1. The `producer` or `consumer` function spawns a new asynchronous context that attempts to send an
   outgoing message after the returned promise has been settled.
2. Your application has other incoming communication channels, such as an HTTP API, that may lead to
   an attempt to send an outgoing message after `IO.close()` has closed the connection.

In these or other similar scenarios, it is recommended to call `IO.seal()` to stop receiving new
messages, ensure that any code execution that may send outgoing messages is completed before
calling `IO.close()`.

## Diagnostics

`IO` emits events for testing, diagnostics, or logging purposes.

`IO.diagnose(event: string, listener: Function): void`

Subscribe to one of the diagnostic events:

- `open`: connection is restored[^2]
- `close`: connection is [closed](https://amqp-node.github.io/amqplib/channel_api.html#model_events)
- `flow`: back pressure is applied to a channel (channel type is passed as an argument)
- `drain`: back pressure is removed from a channel (channel type is passed as an argument)

[^2]: As [`connect`](#connect) function returns an instance of `IO` *after* the connection has been
established, there is no way to capture the initial `open` event.

### Example

```javascript
io.diagnose('flow', () => console.log('Back pressure was applied'))
```
